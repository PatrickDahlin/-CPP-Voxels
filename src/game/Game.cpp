#include "game/Game.hpp"
#include "core/Macros.hpp"
#include "graphics/RenderPass.hpp"
#include "graphics/GLTexture.hpp"
#include "graphics/ShaderProgram.hpp"
#include "graphics/Camera.hpp"
#include "graphics/VertexArray.hpp"
#include "graphics/GLBuffer.hpp"
#include "core/Time.hpp"
#include "core/Files.hpp"

bool 			Game::running = true;
/*
void do_imgui_render(ImDrawData* data)
{
	return;
	// no culling, no depth, scissor, alpha blending
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_CULL_FACE);
	glEnable(GL_BLEND);
	VertexArray arr;
	for (int n = 0; n < data->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = data->CmdLists[n];
		const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
        const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
        for(int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			const ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];
			if(cmd->UserCallback)
			{
				cmd->UserCallback(cmd_list, cmd);
			}
			else
			{
				GLTexture* myTex = (GLTexture*)(cmd->TextureId);
				myTex->bind();

				arr.clear();
				
				// Vertexarray handles this pointer and deletes it
				GLBuffer* el_buf = new GLBuffer(BufferType::ELEMENT_BUFFER, 
								(void*)idx_buffer, 
								sizeof(ImDrawIdx) * cmd->ElemCount,
								cmd->ElemCount);
				
				GLBuffer v_buf(BufferType::ARRAY_BUFFER,
								(void*)vtx_buffer,
								sizeof(ImDrawVert) * cmd->ElemCount,
								cmd->ElemCount);

				// Setting up data pointers for vertices
				// we're using interleaved format here
				v_buf.data_pointer(SHADER_POSITION_LOCATION, 2,
								GL_FLOAT, sizeof(ImDrawVert), 
								false, (void*)0);
				v_buf.data_pointer(SHADER_UV_LOCATION, 2, 
								GL_FLOAT, sizeof(ImDrawVert), 
								false, (void*)offsetof(ImDrawVert, uv));
				v_buf.data_pointer(SHADER_COLOR_LOCATION, 4, 
								GL_UNSIGNED_BYTE, sizeof(ImDrawVert), 
								true, (void*)offsetof(ImDrawVert, col));
				
				arr.add_buffer(v_buf);
				arr.set_element_buffer(el_buf);
				
				arr.draw();
			}
		}
	}
	glEnable(GL_CULL_FACE);
	glEnable(GL_DEPTH_TEST);
}
*/
Game::Game(GameWindow* window) :
game_window(window),
input(window),
main_scene(nullptr)
{
	printf("Setting up Game\n");
	uicam = new Camera(0, window->get_width(), 0, window->get_height());

	input.show_cursor(false);

	/*ImGuiIO& io = ImGui::GetIO();
	io.DisplaySize = ImVec2(window->get_width(), window->get_height());
	io.RenderDrawListsFn = do_imgui_render; 


	unsigned char* pixels;
	int width, height;
	io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);
	// TODO: At this points you've got the texture data and you need to upload that your your graphic system:
	//MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA)
	GLTexture* myTex = new GLTexture(pixels, width, height, ColorFormat::RGBA);
	// TODO: Store your texture pointer/identifier (whatever your engine uses) in 'io.Fonts->TexID'. This will be passed back to your via the renderer.
	io.Fonts->TexID = (void*)myTex;

	std::string vert = read_file("data/shaders/Basic-vert.glsl");
	std::string frag = read_file("data/shaders/Basic-frag.glsl");
	std::string header = read_file("data/shaders/Shader_Header.glsl");
	imgui_shader = new ShaderProgram(vert.c_str(), frag.c_str(), header.c_str());
*/
	//glScissor(0,0,window->get_width(), window->get_height());
}

Game::~Game()
{}

void Game::load()
{
	main_scene = new MainScene(&input, &scene_manager);
	scene_manager.switch_to_scene(main_scene);

	glClearColor(0.3f, 0.5f, 0.8f, 1.0f);
	glEnable(GL_DEPTH_TEST);
	glDisable(GL_SCISSOR_TEST);
}

void Game::run()
{
	auto last_frame = Clock::now();
	float delta_time = 0.0f;

	Time::set_start(); // Only accessible here, sets starting point of application and
						// is used in Time::time_since_startup_sec();

	while(running)
	{
		last_frame = Clock::now();

		input.poll_events();

		glBindBuffer(GL_ARRAY_BUFFER, 0);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
		glBindVertexArray(0);

		/*ImGuiIO& io = ImGui::GetIO();
		io.DeltaTime = delta_time;
		io.MousePos = ImVec2(input.get_mouse_pos().x, input.get_mouse_pos().y);
		io.MouseDown[0] = input.get_mouse_btn(0) == KeyState::PRESSED ||
							input.get_mouse_btn(0) == KeyState::REPEAT;
		io.MouseDown[1] = input.get_mouse_btn(1) == KeyState::PRESSED ||
							input.get_mouse_btn(1) == KeyState::REPEAT;
		*/
		//ImGui::NewFrame();

		// @Temporary
		if(input.get_key(SDLK_ESCAPE) == KeyState::PRESSED)
			Game::quit();

		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		RenderPass* pass = new RenderPass;

		scene_manager.update(delta_time);
		scene_manager.render(pass);
		
		pass->do_render();

		
		//imgui_shader->use();
		//imgui_shader->upload_projection(uicam->get_projection());
		//imgui_shader->upload_view(uicam->get_view());
		//imgui_shader->upload_model(glm::mat4(1.0f));
		//ImGui::Render(); 

		game_window->swap_buffers();
		delete pass;

		//
		// Frametime calculation
		//
		// Calculate how long processing took, we need to calculate how long we need to wait for fps limit
		auto delta = Clock::now() - last_frame;
		double delta_ms = std::chrono::duration_cast<std::chrono::nanoseconds>(delta).count() / 1000000.0;
		
		if(delta_ms < 16)
		{
			SDL_Delay((int)(16 - delta_ms));
		}

		// Calculate the deltatime for this frame including the fps-limit time
		delta = Clock::now() - last_frame;
		delta_ms = std::chrono::duration_cast<std::chrono::nanoseconds>(delta).count() / 1000000.0;
		delta_time = (float)(delta_ms / 1000.0);
	}

	scene_manager.dispose();
}

void Game::quit()
{
	running = false;
	coutln("Reqested quit");
}

