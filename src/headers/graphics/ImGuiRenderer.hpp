#ifndef _IMGUIRENDERER_HPP_
#define _IMGUIRENDERER_HPP_

#include "graphics/VertexArray.hpp"
#include "graphics/GLBuffer.hpp"
#include "graphics/Shader_vars.hpp"

#include <imgui/imgui.h>
#include <GL/glew.h>
#include <iostream>


void render_imgui(ImDrawData* data)
{
	ImGuiIO& io = ImGui::GetIO();
    int fb_width = (int)(io.DisplaySize.x * io.DisplayFramebufferScale.x);
    int fb_height = (int)(io.DisplaySize.y * io.DisplayFramebufferScale.y);
    
	if (fb_width == 0 || fb_height == 0)
        return;
	
	data->ScaleClipRects(io.DisplayFramebufferScale);


	GLenum last_active_texture; glGetIntegerv(GL_ACTIVE_TEXTURE, (GLint*)&last_active_texture);
    glActiveTexture(GL_TEXTURE0);
    GLint last_program; glGetIntegerv(GL_CURRENT_PROGRAM, &last_program);
    GLint last_texture; glGetIntegerv(GL_TEXTURE_BINDING_2D, &last_texture);
    GLint last_sampler; glGetIntegerv(GL_SAMPLER_BINDING, &last_sampler);
    GLint last_array_buffer; glGetIntegerv(GL_ARRAY_BUFFER_BINDING, &last_array_buffer);
    GLint last_element_array_buffer; glGetIntegerv(GL_ELEMENT_ARRAY_BUFFER_BINDING, &last_element_array_buffer);
    GLint last_vertex_array; glGetIntegerv(GL_VERTEX_ARRAY_BINDING, &last_vertex_array);
    GLint last_polygon_mode[2]; glGetIntegerv(GL_POLYGON_MODE, last_polygon_mode);
    GLint last_viewport[4]; glGetIntegerv(GL_VIEWPORT, last_viewport);
    GLenum last_blend_src_rgb; glGetIntegerv(GL_BLEND_SRC_RGB, (GLint*)&last_blend_src_rgb);
    GLenum last_blend_dst_rgb; glGetIntegerv(GL_BLEND_DST_RGB, (GLint*)&last_blend_dst_rgb);
    GLenum last_blend_src_alpha; glGetIntegerv(GL_BLEND_SRC_ALPHA, (GLint*)&last_blend_src_alpha);
    GLenum last_blend_dst_alpha; glGetIntegerv(GL_BLEND_DST_ALPHA, (GLint*)&last_blend_dst_alpha);
    GLenum last_blend_equation_rgb; glGetIntegerv(GL_BLEND_EQUATION_RGB, (GLint*)&last_blend_equation_rgb);
    GLenum last_blend_equation_alpha; glGetIntegerv(GL_BLEND_EQUATION_ALPHA, (GLint*)&last_blend_equation_alpha);
    GLboolean last_enable_blend = glIsEnabled(GL_BLEND);
    GLboolean last_enable_cull_face = glIsEnabled(GL_CULL_FACE);
    GLboolean last_enable_depth_test = glIsEnabled(GL_DEPTH_TEST);
	GLboolean last_enable_scissor_test = glIsEnabled(GL_SCISSOR_TEST);

	glViewport(0, 0, (GLsizei)fb_width, (GLsizei)fb_height);

	//printf("IMGUI render begin\n");
	glDisable(GL_DEPTH_TEST);
	glDisable(GL_CULL_FACE);
	glEnable(GL_BLEND);
	glBlendEquation(GL_FUNC_ADD);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	glEnable(GL_SCISSOR_TEST);
	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

	GLuint vao;
	glGenVertexArrays(1, &vao);
	glBindVertexArray(vao);

	glBindSampler(0, 0); // Rely on combined texture/sampler state.

	for (int n = 0; n < data->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = data->CmdLists[n];
		const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
        const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
        const ImDrawIdx* idx_buffer_offset = 0;
		
		GLuint	elem_buf, v_buf;
		glGenBuffers(1, &elem_buf);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, elem_buf);
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx), idx_buffer, GL_DYNAMIC_DRAW);

		//printf("uploaded element buffer\n");

		glGenBuffers(1, &v_buf);
		glBindBuffer(GL_ARRAY_BUFFER, v_buf);
		glBufferData(GL_ARRAY_BUFFER, cmd_list->VtxBuffer.Size * sizeof(ImDrawVert), vtx_buffer, GL_DYNAMIC_DRAW);

		//printf("uploaded vertex buffer\n");

		glEnableVertexAttribArray(SHADER_POSITION_LOCATION);
		glVertexAttribPointer(SHADER_POSITION_LOCATION,
								2,
								GL_FLOAT,
								GL_FALSE,
								sizeof(ImDrawVert),
								(void*)0);
		
		glEnableVertexAttribArray(SHADER_UV_LOCATION);
		glVertexAttribPointer(SHADER_UV_LOCATION,
								2,
								GL_FLOAT,
								GL_FALSE,
								sizeof(ImDrawVert),
								(void*)(2*sizeof(float)));
		
		glEnableVertexAttribArray(SHADER_COLOR_LOCATION);
		glVertexAttribPointer(SHADER_COLOR_LOCATION,
								4,
								GL_UNSIGNED_BYTE,
								GL_TRUE,
								sizeof(ImDrawVert),
								(void*)(4*sizeof(float)));
		
		for(int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			
			const ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];
			
			GLTexture* myTex = (GLTexture*)(cmd->TextureId);
			myTex->bind();

			glScissor((int)cmd->ClipRect.x, (int)(fb_height - cmd->ClipRect.w), (int)(cmd->ClipRect.z - cmd->ClipRect.x), (int)(cmd->ClipRect.w - cmd->ClipRect.y));

			glDrawElements(GL_TRIANGLES, cmd->ElemCount, GL_UNSIGNED_SHORT, idx_buffer_offset);

			idx_buffer_offset += cmd->ElemCount;
		}

		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		glDeleteBuffers(1, &elem_buf);
		glDeleteBuffers(1, &v_buf);		
	}

	glBindVertexArray(0);
	glDeleteVertexArrays(1, &vao);


	glUseProgram(last_program);
    glBindTexture(GL_TEXTURE_2D, last_texture);
    glBindSampler(0, last_sampler);
    glActiveTexture(last_active_texture);
    glBindVertexArray(last_vertex_array);
    glBindBuffer(GL_ARRAY_BUFFER, last_array_buffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, last_element_array_buffer);
    glBlendEquationSeparate(last_blend_equation_rgb, last_blend_equation_alpha);
    glBlendFuncSeparate(last_blend_src_rgb, last_blend_dst_rgb, last_blend_src_alpha, last_blend_dst_alpha);
    if (last_enable_blend) glEnable(GL_BLEND); else glDisable(GL_BLEND);
    if (last_enable_cull_face) glEnable(GL_CULL_FACE); else glDisable(GL_CULL_FACE);
    if (last_enable_depth_test) glEnable(GL_DEPTH_TEST); else glDisable(GL_DEPTH_TEST);
    if (last_enable_scissor_test) glEnable(GL_SCISSOR_TEST); else glDisable(GL_SCISSOR_TEST);
	glPolygonMode(GL_FRONT_AND_BACK, last_polygon_mode[0]);
	glViewport(last_viewport[0], last_viewport[1], (GLsizei)last_viewport[2], (GLsizei)last_viewport[3]);
}

#endif